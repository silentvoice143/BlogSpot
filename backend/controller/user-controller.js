import User from "../models/user.js";
import Token from "../models/token.js";
import bcrypt from "bcrypt";
import nodemailer from "nodemailer";
import rand from "randomstring";
import jwt from "jsonwebtoken";
import cookieparser from "cookie-parser";
import "dotenv/config";
const saltRounds = 10;
const someOtherPlaintextPassword = "not_bacon";

export const signupUser = async (req, res) => {
  const { name, email, password } = req.body;

  let emailregex = new RegExp("[a-z0-9]+@[a-z]+.[a-z]{2,3}");

  if (!emailregex.test(email)) {
    return res.status(400).json({ message: "Email is not valid" });
  }

  try {
    // Check if the email is already registered
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log("email already exist");
      return res.status(400).json({ message: "Email already registered" });
    }

    // Create a new user
    bcrypt.genSalt(saltRounds, function (err, salt) {
      bcrypt.hash(password, salt, async function (err, hash) {
        // Store hash in your password DB.
        let newUser = new User({ name: name, email: email, password: hash });
        await newUser.save();
      });
    });
    console.log("registered user");
    return res.status(200).json({ message: "User registered successfully" });
  } catch (err) {
    return res
      .status(500)
      .json({ error: "An error occurred while registering the user" });
  }
};

export const loginUser = async (req, res) => {
  const { email, password } = req.body;
  let user = await User.findOne({ email: email });
  // console.log(user);
  if (!user) {
    return res.status(400).json({ msg: "user not exist" });
  } else {
    try {
      const match = await bcrypt.compare(password, user.password);
      if (match) {
        //here we are using jwt token for login purpose
        //accessToken not lastlong for long so we need a refreshToken
        //jwt combine body {user} and a secret{generated by crypto} key to make a token
        // console.log("match found");
        const accessToken = jwt.sign(
          {
            email: user.email,
            userId: user._id,
            name: user.name,
          },
          process.env.ACCESS_SECRET_KEY,
          { expiresIn: "15M" }
        );
        const refreshToken = jwt.sign(
          {
            email: user.email,
            userId: user._id,
            name: user.name,
          },
          process.env.REFREASH_SECRET_KEY,
          { expiresIn: "1d" }
        );

        //NOW WE HAVE TO SAVE THIS TOKEN IN DATABASE SO WE CAN CHECK USER IS LOGIN OR NOT
        //AND REFRESH THE ACCESSTOKEN EVERY 15 MINUTES

        let newToken = new Token({ token: refreshToken, email: user.email });
        await newToken.save();
        res.cookie("jwt", refreshToken, {
          httpOnly: true,
          sameSite: "None",
          secure: true,
          maxAge: 24 * 60 * 60 * 1000,
        });
        return res.status(200).json({
          accessToken: accessToken,
          email: user.email,
          name: user.name,
        });
      } else {
        return res.status(400).json({ msg: "password incorrect" });
      }
    } catch (err) {
      return res.status(400).json({ msg: "error while login user" });
    }
  }
};

export const logoutUser = (req, res) => {
  const authHeader = req.headers["authorization"];
  jwt.sign(authHeader, "", { expiresIn: 0.01 }, (logout, err) => {
    if (logout) {
      res.status(200).json({ msg: "You have been Logged Out" });
    } else {
      res.status(400).json({ msg: "Error" });
    }
  });
};

export const refreshToken = async (req, res) => {
  const email = req.body.email;
  const refreshToken = await Token.find({ email: email });
  if (refreshToken) {
    // Destructuring refreshToken from cookie

    // Verifying refresh token
    jwt.verify(
      refreshToken,
      process.env.REFREASH_SECRET_KEY,
      async (err, decoded) => {
        if (err) {
          // Wrong Refesh Token
          return res.status(406).json({ message: "Unauthorized" });
        } else {
          // Correct token we send a new access token
          let user = await User.findOne({ email: email });
          const accessToken = jwt.sign(
            {
              email: user.email,
              userId: user._id,
              name: user.name,
            },
            process.env.ACCESS_SECRET_KEY,
            { expiresIn: "15M" }
          );
          return res.json({ accessToken });
        }
      }
    );
  } else {
    return res.status(406).json({ message: "Unauthorized" });
  }
};

const forgotPassword = async (req, res) => {
  try {
    const email = req.body.email;
    const user = User.findOne({ email: email });
    if (user) {
    } else {
      return res
        .status(200)
        .json({ success: true, msg: "This email does not exist" });
    }
  } catch (error) {
    return res.status(400).json({ success: failure, msg: error.message });
  }
};
